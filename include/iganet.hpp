/**
   @file include/iganet.hpp

   @brief Isogeometric analysis network
   
   @author Matthias Moller
      
   @copyright This file is part of the IgaNet project
   
   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

#include <bspline.hpp>

#pragma once

namespace iganet {

  /**
   * IgANetGeneratorImpl
   *
   * @note Following the discussion of module overship here
   *
   * https://pytorch.org/tutorials/advanced/cpp_frontend.html#module-ownership
   *
   * we implement a generator implementation class following
   *
   * https://pytorch.org/tutorials/advanced/cpp_frontend.html#the-generator-module
   */
  template<typename real_t>
  class IgANetGeneratorImpl :
    public torch::nn::Module
  {
  public:
    // Constructor
    IgANetGeneratorImpl(const std::vector<int64_t>& layers)
    {
      // Generate vector of linear layers and register them as fcX
      for (auto i=0; i<layers.size()-1; ++i)
        {
          fc.emplace_back(register_module("fc" + std::to_string(i),
                                          torch::nn::Linear(layers[i], layers[i+1])));
        }
    }

    // Forward evaluation
    torch::Tensor forward(torch::Tensor x)
    {
      // Standard feed-forward neural network with ReLU activation functions
      for (auto it=fc.begin(); it!=fc.end()-1; ++it)
        x = torch::relu(it->forward(x));
      x = fc.end()->forward(x);
      return x;
    }

  private:
    // Vector of linear layers
    std::vector<torch::nn::Linear> fc;
  };

  /**
   * IgANetGenerator
   *
   * @note: This class is normally generated by the TORCH_MODULE
   * macro. Since the latter cannot handle templated classes
   * correctly, we give the implementation explicitly
   */
  template<typename real_t>
  class IgANetGenerator :
    public torch::nn::ModuleHolder<IgANetGeneratorImpl<real_t>> {

  public:
    using torch::nn::ModuleHolder<IgANetGeneratorImpl<real_t>>::ModuleHolder;
    using Impl = IgANetGeneratorImpl<real_t>;
  };

  /**
   * IgaNet
   */
  template<typename real_t,
           template<typename, short_t, short_t...> class BSpline_t,
           short_t... Degrees>
  class IgANet : public core<real_t>
  {
  private:
    // Dimension of the differential equation
    static constexpr const short_t dim_ = sizeof...(Degrees);

    // B-spline representation of the geometry
    BSpline_t<real_t, dim_, Degrees...> geo_;

    // B-spline representation of the right-hand side
    BSpline_t<real_t, 1, Degrees...> rhs_;

    // B-spline representation of the solution
    BSpline_t<real_t, 1, Degrees...> sol_;

    // Input tensor
    torch::Tensor input_;

    // Tensor servering as global input
    torch::Tensor input__;

    // IgANet generator
    IgANetGenerator<real_t> net_;

  public:
    // Constructor: layers + bspline (same for all)
    IgANet(const std::vector<int64_t>& layers,
           const std::array<int64_t,dim_>& bspline_ncoeffs)
      : IgANet(layers, bspline_ncoeffs, bspline_ncoeffs, bspline_ncoeffs)
    {
    }

    // Constructor: layers + geo-bspline + rhs-bspline + sol-bspline
    IgANet(const std::vector<int64_t>& layers,
           const std::array<int64_t,dim_>& geo_bspline_ncoeffs,
           const std::array<int64_t,dim_>& rhs_bspline_ncoeffs,
           const std::array<int64_t,dim_>& sol_bspline_ncoeffs)
      : core<real_t>(),

        // Construct the different B-Spline objects individually
        geo_(geo_bspline_ncoeffs, BSplineInit::greville),
        rhs_(rhs_bspline_ncoeffs, BSplineInit::ones),
        sol_(sol_bspline_ncoeffs, BSplineInit::random),

        // Construct one large tensor comprising all B-Spline object's
        // coefficient vectors - we need this complicated construction
        // to first concatenate the multiple
        // std::array<torch::Tensor,*> objects into a single
        // std::array<torch::Tensor,*> object and then initialize a
        // new large torch::Tensor with its data
        input__(torch::concat(
                              concat(geo_.coeffs(),
                                     rhs_.coeffs(),
                                     std::array<torch::Tensor,1>({torch::ones({dim_}, core<real_t>::options_)}))
                              )
                ),

        // Construct the deep neural network with the large tensor as
        // input and the coefficient vector of the solution's BSpline
        // object as output
        net_(concat(std::vector<int64_t>{static_cast<int64_t>(input__.size(0))},
                    layers,
                    std::vector<int64_t>{sol_.ncoeffs()}))
    {
      // Now that everything is in placed we swap the coefficient
      // vectors of the B-Spline objects with views on parts of the
      // one large tensor
      int64_t count = 0;

      // Geometry
      for (short_t i=0; i<dim_; ++i)
        {
          geo_.coeffs(i) = input__.index({torch::indexing::Slice(count,
                                                                 count+=geo_.ncoeffs(),
                                                                 1)});
        }

      // Right-hand side
      rhs_.coeffs(0) = input__.index({torch::indexing::Slice(count,
                                                             count+=rhs_.ncoeffs(),
                                                             1)});

      // Input tensor
      input_ = input__.index({torch::indexing::Slice(count,
                                                     count+=dim_,
                                                     1)});
    }

    // Constructor: layers + bspline (same for all)
    IgANet(const std::vector<int64_t>& layers,
           const std::array<std::vector<real_t>,dim_>& bspline_kv)
      : IgANet(layers, bspline_kv, bspline_kv, bspline_kv)
    {
    }

        // Constructor: layers + geo-bspline + rhs-bspline + sol-bspline
    IgANet(const std::vector<int64_t>& layers,
           const std::array<std::vector<real_t>,dim_>& geo_bspline_kv,
           const std::array<std::vector<real_t>,dim_>& rhs_bspline_kv,
           const std::array<std::vector<real_t>,dim_>& sol_bspline_kv)
      : core<real_t>(),

        // Construct the different B-Spline objects individually
        geo_(geo_bspline_kv, BSplineInit::greville),
        rhs_(rhs_bspline_kv, BSplineInit::ones),
        sol_(sol_bspline_kv, BSplineInit::random),

        // Construct one large tensor comprising all B-Spline object's
        // coefficient vectors - we need this complicated construction
        // to first concatenate the multiple
        // std::array<torch::Tensor,*> objects into a single
        // std::array<torch::Tensor,*> object and then initialize a
        // new large torch::Tensor with its data
        input__(torch::concat(
                              concat(geo_.coeffs(),
                                     rhs_.coeffs(),
                                     std::array<torch::Tensor,1>({torch::ones({dim_}, core<real_t>::options_)}))
                              )
                ),

        // Construct the deep neural network with the large tensor as
        // input and the coefficient vector of the solution's BSpline
        // object as output
        net_(concat(std::vector<int64_t>{static_cast<int64_t>(input__.size(0))},
                    layers,
                    std::vector<int64_t>{sol_.ncoeffs()}))
    {
      // Now that everything is in placed we swap the coefficient
      // vectors of the B-Spline objects with views on parts of the
      // one large tensor
      int64_t count = 0;

      // Geometry
      for (short_t i=0; i<dim_; ++i)
        {
          geo_.coeffs(i) = input__.index({torch::indexing::Slice(count,
                                                                 count+=geo_.ncoeffs(),
                                                                 1)});
        }

      // Right-hand side
      rhs_.coeffs(0) = input__.index({torch::indexing::Slice(count,
                                                             count+=rhs_.ncoeffs(),
                                                             1)});

      // Input tensor
      input_ = input__.index({torch::indexing::Slice(count,
                                                     count+=dim_,
                                                     1)});
    }

    // Returns a constant reference to the B-spline representation of the geometry
    inline const BSpline_t<real_t, dim_, Degrees...>& geo() const
    {
      return geo_;
    }

    // Returns a non-constant reference to the B-spline representation of the geometry
    inline BSpline_t<real_t, dim_, Degrees...>& geo()
    {
      return geo_;
    }

    // Returns a constant reference to the B-spline representation of the right-hand side
    inline const BSpline_t<real_t, 1, Degrees...>& rhs() const
    {
      return rhs_;
    }

    // Returns a non-constant reference to the B-spline representation of the right-hand side
    inline BSpline_t<real_t, 1, Degrees...>& rhs()
    {
      return rhs_;
    }

    // Returns a constant reference to the B-spline representation of the solution
    inline const BSpline_t<real_t, 1, Degrees...>& sol() const
    {
      return sol_;
    }

    // Returns a non-constant reference to the B-spline representation of the solution
    inline BSpline_t<real_t, 1, Degrees...>& sol()
    {
      return sol_;
    }

    // Returns a constant reference to the input tensor
    inline const torch::Tensor* input() const
    {
      return input_;
    }

    // Returns a non-constant reference to the input tensor
    inline torch::Tensor* input()
    {
      return input_;
    }

    // Returns the dimension
    inline constexpr short_t dim() const
    {
      return dim_;
    }

    // Returns a string representation of the IgANet object
    inline void pretty_print(std::ostream& os = std::cout) const
    {
      os << "=== IgANet ===\n"
         << "net = " << net_ << "\n"
         << "geo = " << geo_ << "\n"
         << "rhs = " << rhs_ << "\n"
         << "sol = " << sol_;
    }

    // Plots the B-Spline geometry
    inline auto plot_geo(int64_t xres=10, int64_t yres=10, int64_t zres=10) const
    {
      return geo_.plot(xres, yres, zres);
    }

    // Plots the B-Spline right-hand side
    inline auto plot_rhs(int64_t xres=10, int64_t yres=10, int64_t zres=10) const
    {
      return rhs_.plot(rhs_, xres, yres, zres);
    }
    
    // Plots the B-Spline solution
    inline void plot_sol(int64_t xres=10, int64_t yres=10, int64_t zres=10) const
    {
      return rhs_.plot(sol_, xres, yres, zres);
    }
  };

  /// Print (as string) a IgANet object
  template<typename real_t,
           template<typename, short_t, short_t...> class BSpline_t,
           short_t... Degrees>
  inline std::ostream& operator<<(std::ostream& os,
                                  const IgANet<real_t, BSpline_t, Degrees...>& obj)
  {
    obj.pretty_print(os);
    return os;
  }

} // namespace iganet
